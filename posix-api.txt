      今天学习一下这个Posix api,刚开始看到这个词的时候直接蒙住了，什么也不了解，后来搜索知道了这是操作系统给程序员提供的“标准工具箱”，可以在不同的操作系统上使用来运行程序。它可以统一规范，还可以移植使用。
     1.网络通信：socket,bind,listen,accept,send,recv,close,connect
     socket（地址族、套接字类型、协议）: 申请身份证 fd ，组装工具箱（绑定协议与数据结构）
                                                                此时的 fd 处于CLOSED状态
     bind  ：为套接字分配一个本地的、唯一的（或通配的）网络身份标识（IP:Port）
     listen :  主要作用是“变被动为主动”，把参数fd状态改为LISTEN,并“摆好两张桌子排队”。一张桌子是三次握手完毕的，另一张是只进行了syn但没有ack,对应内核仍处于recv状态.当客户端 发来第一个 SYN时                   内核就会为它在这个队列里分配一个位置，回复 SYN+ACK并等待客户端的最后确认（ACK）。如果队列满了，新的连接请求会被直接丢弃或拒绝。backlog 参数主要限制的是未完成队列的长度。如果                      backlog 设置得太小, 很多客户端会因为队列满而连接失败（Connection Refused）。
                 listen-LT模式：一直进行取连接。lisent-ET模式：循环取，直到 fd 为 -1。

     syn泛洪：只syn不ack,导致内核分配无效资源。
     syn泛洪解决：SYN Cookie ,当收到 SYN 时，服务器不创建连接，而是根据客户端的 IP、端口和一些加密算法，算出一个特殊的序列号,服务器直接回复 SYN-ACK，把这个序列号给客户端,如果客户端是正常的，                          它会回发 ACK，并且 ACK 号里包含了那个序列号+1。服务器收到 ACK 后，验证这个序列号是合法的，此时才真正分配资源，建立连接。
     accept: 从三次握手完毕的队列里取连接，创建对应的fd提供连接通道，阻塞等待新的三次握手完毕客户。
     send:    核心作用不是“把数据发出去”，而是“把数据拷贝进内核的发送缓冲区”。send() 是应用程序与内核协议栈之间的“搬运工”。它负责把你的数据安全地送进内核的大门，之后的路（网络传输）就交给                  TCP/IP 协议栈去走了。内核并不会立刻发送数据包。TCP 是流式协议，内核会根据拥塞控制和Nagle 算法来决定什么时候把缓冲区里的数据组装成 TCP 报文段，加上 TCP 头部和 IP 头部，然后交给 IP                  层进一步交给网卡驱动发送。send() 返回并不代表对方已经收到了数据。它只代表“数据安全地进入了内核的仓库”。
     recv ： 就是你的“数据接收员”。它负责从内核维护的“接收邮箱”里把数据拿出来交给你，并告诉你对方是发了数据、还是想断开连接、亦或是出了什么岔子。
     close:   四次挥手  
     