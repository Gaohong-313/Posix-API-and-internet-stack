1.三次握手：  出现：在建立可靠连接时。客户端connect函数调用时。服务器阻塞等待连接时。客户端的状态从 CLOSED 变为 SYN_SENT；服务器的状态从 LISTEN 变为 SYN_RECV。
                     三次握手内容：A告诉B,我要和你说话(A向B发送syn) -> B告诉A,我知道了你要和我说话(B向A发送syn+ack) -> A告诉B，我要开始说话了(ack)。
	     只有这三步走完，真正的通话（数据传输）才正式开始。
                     1.1 滑动窗口：提高传输效率
                     1.2 拥塞控制 (Congestion Control) & 慢启动 (Slow Start) ：维护网络整体健康，防止因为发送太快导致网络瘫痪（堵车）。
                     1.3 延迟确认 (Delayed ACK) ：减少网络中小包的数量，提高带宽利用率。
                     1.4 超时重传 (Retransmission Timeout, RTO) : 保证数据的可靠性。


2.四次挥手：出现：断开连接
                    四次挥手内容：一次>A(发起主动方)要断开连接，向B发送FIN包，调用close，A进入Await_1状态 ————> 二次>B(回应)发送ack给A————>三次>B(发起)向A发送完剩下数据之后向A发送FIN                       包 B进入Bwait_1状态————>四次>A(回应)向B发送ack，A进入Await_2状态,B进入关闭状态
                    Await_2状态：在第四次挥手后，主动关闭方（A）不能直接消失，必须进入 TIME_WAIT 状态，等待 2MSL（Maximum SegmentSegment Lifetime，通常 30～120 秒）。
	   	
                             为什么要等？有两个主要原因：
	    2.1确保 B 能收到最后的 ACK：
		如果 A 发给 B 的最后一个 ACK 丢了，B 会重传它的 FIN 包。
		A 在 TIME_WAIT 状态下，如果收到 B 重传的 FIN，可以再次回复 ACK，确保 B 能正常关闭。
		如果不等，A 直接 CLOSED，B 发来的 FIN/ACK 无人响应，B �<refer>一直卡在 LAST_ACK 状态，无法释放资源。

	    2.2防止“旧包”干扰新连接：
		等待 2MSL 能让网络中属于这个旧连接的所有数据包（迟到的、迷路的）全部消失。
		如果不等，立刻用同样的端口建立新连接，旧连接的“幽灵数据包”可能混入新连接，导致数据错乱。
    